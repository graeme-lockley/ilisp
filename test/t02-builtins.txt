(car)
> (:exception (ExpectedArgumentCount . {:arguments () :arg-count 1 :procedure car}))

(car 1)
> (:exception (InvalidArgument . {:received 1 :expected-type "pair" :arg-number 0 :procedure car}))

(car '(1 2) '(3 4))
> (:exception (ExpectedArgumentCount . {:arguments ((1 2) (3 4)) :arg-count 1 :procedure car}))

(car '())
> (:exception (InvalidArgument . {:received () :expected-type "pair" :arg-number 0 :procedure car}))

(car '(1 2 3 4 5))
> 1


(cdr)
> (:exception (ExpectedArgumentCount . {:arguments () :arg-count 1 :procedure cdr}))

(cdr 1)
> (:exception (InvalidArgument . {:received 1 :expected-type "pair" :arg-number 0 :procedure cdr}))

(cdr '(1 2) '(3 4))
> (:exception (ExpectedArgumentCount . {:arguments ((1 2) (3 4)) :arg-count 1 :procedure cdr}))

(cdr '())
> (:exception (InvalidArgument . {:received () :expected-type "pair" :arg-number 0 :procedure cdr}))

(cdr '(1 2 3 4 5))
> (2 3 4 5)


(count)
> (:exception (ExpectedArgumentCount . {:arguments () :arg-count 1 :procedure count}))

(count 1)
> (:exception (InvalidArgument . {:received 1 :expected-type "pair" :arg-number 0 :procedure count}))

(count '(1 2) '(3 4))
> (:exception (ExpectedArgumentCount . {:arguments ((1 2) (3 4)) :arg-count 1 :procedure count}))

(count '())
> 0

(count '(1 2 3 4 5))
> 5

(do (assoc! (car **root**) 'fred {}) fred)
> {}

(assoc! fred 'a 1)
> {a 1}

fred
> {a 1}

(assoc! fred 'b 2)
> {b 2 a 1}

fred
> {b 2 a 1}

(assoc! fred)
> {b 2 a 1}

(assoc! fred 'b 3)
> {b 3 a 1}

fred
> {b 3 a 1}

(assoc! fred :b 4)
> {:b 4 b 3 a 1}

fred
> {:b 4 b 3 a 1}

(assoc! fred a 1)
> (:exception (UnknownSymbol . {name a}))

(dissoc! fred)
> {:b 4 b 3 a 1}

(dissoc! fred 'a)
> {:b 4 b 3}

fred
> {:b 4 b 3}

(list 1 2 3)
> (1 2 3)

(list? 0)
> ()

(list? "hello")
> ()

(list? 'fred)
> ()

(list? :at)
> ()

(list? [1])
> ()

(list? {:a 1})
> ()

(list? list)
> ()

(list? list?)
> ()

(list? ())
> t

(list? '(1 2 3))
> t

(list? '(1 2) '(3 4))
> (:exception (ExpectedArgumentCount . {:arguments ((1 2) (3 4)) :arg-count 1 :procedure list?}))

(pr-str)
> ""

(pr-str 1)
> "1"

(pr-str "hello" 'fred :at [1] {:a 1} '() '(1 (a b c) 3))
> "\"hello\" fred :at [1] {:a 1} () (1 (a b c) 3)"

(str)
> ""

(str 1)
> "1"

(str "hello" 'fred :at [1] {:a 1} '() '(1 (a b c) 3))
> "hellofred:at[1]{:a 1}()(1(abc)3)"

(empty? 1)
> (:exception (InvalidArgument . {:received 1 :expected-type ("pair" "()") :arg-number 0 :procedure empty?}))

(empty? '())
> t

(empty? '(1 2 3))
> ()

(=)
> t

(= 1)
> t

(= 2 2)
> t

(= 2 1)
> ()

(= 2 (+ 1 1) (- 3 1))
> t

(= 2 (+ 1 1) (- 4 1))
> ()

(= 2 '())
> ()

(= 2 "hello")
> ()

(= 2 'fred)
> ()

(= 2 :key)
> ()

(= 2 [1 2])
> ()

(= 2 '(1 2))
> ()

(= 2 {:a 1 :b 2})
> ()

(= '() '())
> t

(= "hello" "world")
> ()

(= "hello" "hello")
> t

(= "hello" '())
> ()

(= "hello" 'fred)
> ()

(= "hello" :key)
> ()

(= "hello" [1 2])
> ()

(= "hello" '(1 2))
> ()

(= "hello" {:a 1 :b 2})
> ()

(= 'hello 'fred)
> ()

(= 'hello 'hello)
> t

(= 'hello :key)
> ()

(= 'hello [1 2])
> ()

(= 'hello '(1 2))
> ()

(= 'hello {:a 1 :b 2})
> ()

(= :hello :key)
> ()

(= :hello :hello)
> t

(= :hello [1 2])
> ()

(= :hello '(1 2))
> ()

(= :hello {:a 1 :b 2})
> ()

(= [1 2] [1 2])
> t

(= [1 2] [1 2 3])
> ()

(= [] [1 2])
> ()

(= [] [])
> t

(= [1 2] '(1 2))
> ()

(= [1 2] {:a 1 :b 2})
> ()

(= '(1 2) '(1 2))
> t

(= '(1 2 3) '(1 2))
> ()

(= '(1 2 3) '())
> ()

(= '(1 2) {:a 1 :b 2})
> ()

(= {:a 1 :b 2} {:a 1 :b 2})
> t

(= {:b 2 :a 1} {:a 1 :b 2})
> t

(= {:b 2 :a 1} {:a 1})
> ()

(= {} {})
> t

(<)
> t

(< 1)
> t

(< 1 2)
> t

(< 1 2 3)
> t

(< 1 1)
> ()

(< "hello" 1)
> (:exception (InvalidArgument . {:received "hello" :expected-type "number" :arg-number 0 :procedure integer-less-than}))

(< 1 "hello")
> (:exception (InvalidArgument . {:received "hello" :expected-type "number" :arg-number 1 :procedure integer-less-than}))

(<=)
> t

(<= 1)
> t

(<= 1 2)
> t

(<= 1 2 3)
> t

(<= 1 1)
> t

(<= 1 0)
> ()

(<= "hello" 1)
> (:exception (InvalidArgument . {:received "hello" :expected-type "number" :arg-number 0 :procedure integer-less-equal}))

(>)
> t

(> 1)
> t

(> 2 1)
> t

(> 3 2 1)
> t

(> 1 1)
> ()

(> "hello" 1)
> (:exception (InvalidArgument . {:received "hello" :expected-type "number" :arg-number 0 :procedure integer-greater-than}))

(>=)
> t

(>= 1)
> t

(>= 2 1)
> t

(>= 3 2 1)
> t

(>= 1 1)
> t

(>= 0 1)
> ()

(>= "hello" 1)
> (:exception (InvalidArgument . {:received "hello" :expected-type "number" :arg-number 0 :procedure integer-greater-equal}))

(read-string)
> (:exception (ExpectedArgumentCount . {:arguments () :max-arg-count 2 :min-arg-count 1 :procedure read-string}))

(read-string 1)
> (:exception (InvalidArgument . {:received 1 :expected-type "string" :arg-number 0 :procedure read-string}))

(read-string "1")
> 1

(read-string "(1 2 3)")
> (1 2 3)

(read-string "(1 2 \"hello\")")
> (1 2 "hello")

(eval '1)
> 1

(eval '(+ 1 2))
> 3

(eval (read-string "(cdr '(1 2 3 4 5))"))
> (2 3 4 5)

(do (load-file "./test/basic.sc") (caar '((1 2) (3 4))))
> 1

(do (load-file "./test/basic.sc") (cadr '((1 2) (3 4))))
> (3 4)

(cons 1 ())
> (1)

(cons 1 (cons 2 (cons 3 (cons 4 ()))))
> (1 2 3 4)

(cons 1 '(2 3 4))
> (1 2 3 4)

(concat)
> ()

(concat () () ())
> ()

(concat 1 2 3)
> (:exception (InvalidArgument . {:received 1 :expected-type "pair" :arg-number 0 :procedure concat}))

(concat '(1 2 3) (cons 1 9))
> (:exception (InvalidArgument . {:received (1 . 9) :expected-type "pair" :arg-number 1 :procedure concat}))

(concat '(1) '(2) '(3))
> (1 2 3)

(concat '(1 2 3) '(4 5 6) '(7 8 9))
> (1 2 3 4 5 6 7 8 9)

;; Testing nth, first and rest functions with lists
(nth (list 1) 0)
>1
(nth (list 1 2) 1)
>2
(nth (list 1 2 ()) 2)
>()
(do 
  (assoc! (car **root**) 'x "x") 
  (assoc! (car **root**) 'x (nth (list 1 2) 2)) 
  x)
>()

(first (list))
>()
(first (list 6))
>6
(first (list 7 8 9))
>7

(rest (list))
>()
(rest (list 6))
>()
(rest (list 7 8 9))
>(8 9)

;; Testing nth, first, rest with vectors
(nth [1] 0)
>1
(nth [1 2] 1)
>2
(nth [1 2] 2)
>()
(nth [1 2 ()] 2)
>()

(first [])
>()
(first [10])
>10
(first [10 11 12])
>10
(rest [])
>()
(rest ())
>()
(rest [10])
>()
(rest [10 11 12])
>(11 12)
(rest (cons 10 [11 12]))
>(11 12)

(apply)
> (:exception (InvalidArgument . {:received () :expected-type "pair" :arg-number 0 :procedure apply}))

(apply 1)
> (:exception (InvalidArgument . {:received 1 :expected-type "procedure" :arg-number 0 :procedure apply}))

(apply +)
> (:exception (InvalidArgument . {:received () :expected-type "pair" :arg-number 1 :procedure apply}))

(apply + '(1 2 3))
> 6

(apply + 1 2 '(3 4))
> 10

(apply + 1 2 3)
> (:exception (InvalidArgument . {:received 3 :expected-type "pair" :arg-number 3 :procedure apply}))

(apply + 1 2 3 '())
> 6

(apply + [1 2 3])
> 6

(apply + 1 2 [3 4])
> 10

(apply + 1 2 3 [])
> 6

(apply + 1 2 3 [])
> 6

(map)
> (:exception (ExpectedArgumentCount . {:arguments () :arg-count 2 :procedure map}))

(map not)
> (:exception (ExpectedArgumentCount . {:arguments ((#PROCEDURE (p) (if p () (=)))) :arg-count 2 :procedure map}))

(map (fn (n) (+ n 1)) 1)
> (:exception (InvalidArgument . {:received 1 :expected-type (pair vector ()) :arg-number 1 :procedure map}))

(map (fn (n) (+ n 1)) '())
> ()

(map (fn (n) (+ n 1)) '(1 2 3 4))
> (2 3 4 5)

(map (fn (n) (+ n 1)) [])
> ()

(map (fn (n) (+ n 1)) [1 2 3 4])
> (2 3 4 5)

(nil? ())
> t

(nil? 1)
> f

(nil? "hello")
> f

(nil? 'hello)
> f

(nil? :hello)
> f

(nil? '(1 2 3))
> f

(nil? [])
> f

(nil? [1 2 3])
> f

(nil? {})
> f

(nil? {:a 1 :b 2})
> f

(nil? (fn (x) (+ x 1)))
> f

(nil? car)
> f

(nil? cond)
> f

(symbol? ())
> f

(symbol? 1)
> f

(symbol? "hello")
> f

(symbol? 'hello)
> t

(symbol? :hello)
> f

(symbol? '(1 2 3))
> f

(symbol? [])
> f

(symbol? [1 2 3])
> f

(symbol? {})
> f

(symbol? {:a 1 :b 2})
> f

(symbol? (fn (x) (+ x 1)))
> f

(symbol? car)
> f

(symbol? cond)
> f

(symbol "hello")
> hello

(symbol? (symbol "hello"))
> t

(keyword? ())
> f

(keyword? 1)
> f

(keyword? "hello")
> f

(keyword? 'hello)
> f

(keyword? :hello)
> t

(keyword? '(1 2 3))
> f

(keyword? [])
> f

(keyword? [1 2 3])
> f

(keyword? {})
> f

(keyword? {:a 1 :b 2})
> f

(keyword? (fn (x) (+ x 1)))
> f

(keyword? car)
> f

(keyword? cond)
> f

(keyword "hello")
> :hello

(keyword :hello)
> :hello

(keyword? (keyword "hello"))
> t

(vector? ())
> f

(vector? 1)
> f

(vector? "hello")
> f

(vector? 'hello)
> f

(vector? :hello)
> f

(vector? '(1 2 3))
> f

(vector? [])
> t

(vector? [1 2 3])
> t

(vector? {})
> f

(vector? {:a 1 :b 2})
> f

(vector? (fn (x) (+ x 1)))
> f

(vector? car)
> f

(vector? cond)
> f

(vector)
> []

(vector? (vector))
> t

(vector 1 "hello" 3)
> [1 "hello" 3]

(vector? (vector 1 "hello" 3))
> t

(sequential? ())
> t

(sequential? 1)
> f

(sequential? "hello")
> f

(sequential? 'hello)
> f

(sequential? :hello)
> f

(sequential? '(1 2 3))
> t

(sequential? [])
> t

(sequential? [1 2 3])
> t

(sequential? {})
> f

(sequential? {:a 1 :b 2})
> f

(sequential? (fn (x) (+ x 1)))
> f

(sequential? car)
> f

(sequential? cond)
> f

(map? ())
> f

(map? 1)
> f

(map? "hello")
> f

(map? 'hello)
> f

(map? :hello)
> f

(map? '(1 2 3))
> f

(map? [])
> f

(map? [1 2 3])
> f

(map? {})
> t

(map? {:a 1 :b 2})
> t

(map? (fn (x) (+ x 1)))
> f

(map? car)
> f

(map? cond)
> f

(hash-map)
> {}

(map? (hash-map))
> t

(hash-map :a 1 :b 2 :c 3)
> {:a 1 :b 2 :c 3}

(map? (hash-map :a 1 :b 2 :c 3))
> t

(hash-map :a 1 :b 2 :c)
> (:exception (InvalidArgument . {:received () :expected-type "pair" :arg-number 5 :procedure hash-map}))

(assoc {})
> {}

(assoc {} :a 1 :b 2 :c 3)
> {:c 3 :b 2 :a 1}

(do (assoc! (car **root**) 'a {:a 1 :b 2 :c 3}) (list (assoc a :a 2 :b 3) a))
> ({:b 3 :a 2 :c 3} {:a 1 :b 2 :c 3})

(dissoc {:a 1 :b 2 :c 3} :a :b)
> {:c 3}

(dissoc {:a 1 :b 2 :c 3} :a :b :d)
> {:c 3}

(do (assoc! (car **root**) 'a {:a 1 :b 2 :c 3}) (list (dissoc a :a :b) a))
> ({:c 3} {:a 1 :b 2 :c 3})

(get)
> (:exception (InvalidArgument . {:received () :expected-type "pair" :arg-number 0 :procedure get}))

(get {})
> {}

(get [] :a)
> (:exception (InvalidArgument . {:received [] :expected-type map :arg-number 0 :procedure get}))

(get {} :a)
> ()

(get {:a 1 :b 2 :c 3} :a)
> 1

(get {:a 1 :b 2 :c 3} :c)
> 3

(get {:a 1 :b 2 :c 3} :d)
> ()

(get {:a 1 :b () :c 3} :b)
> ()

(get {:a 1 :b {"a" 1 "b" 2} :c 3} :b "b")
> 2

(get {:a 1 :b {"a" 1 "b" 2} :c 3} :a "a")
> (:exception (InvalidArgument . {:received 1 :expected-type map :arg-number 0 :procedure get}))

(contains?)
> (:exception (ExpectedArgumentCount . {:arguments () :arg-count 2 :procedure contains?}))

(contains? {})
> (:exception (ExpectedArgumentCount . {:arguments ({}) :arg-count 2 :procedure contains?}))

(contains? [] :a)
> (:exception (InvalidArgument . {:received ([] :a) :expected-type map :arg-number 0 :procedure contains?}))

(contains? {} :a)
> f

(contains? {:a 1 :b 2 :c 3} :a)
> t

(contains? {:a 1 :b 2 :c 3} :c)
> t

(contains? {:a 1 :b 2 :c 3} :d)
> f

(contains? {:a 1 :b () :c 3} :b)
> t

(keys)
> (:exception (ExpectedArgumentCount . {:arguments () :arg-count 1 :procedure keys}))

(keys [])
> (:exception (InvalidArgument . {:received [] :expected-type map :arg-number 0 :procedure keys}))

(keys {})
> ()

(keys {:a 1 :b 2 :c 3})
> (:a :b :c)

(vals)
> (:exception (ExpectedArgumentCount . {:arguments () :arg-count 1 :procedure vals}))

(vals [])
> (:exception (InvalidArgument . {:received [] :expected-type map :arg-number 0 :procedure vals}))

(vals {})
> ()

(vals {:a 1 :b 2 :c 3})
> (1 2 3)

(readdir "./test/my_dir_that_does_not_exist")
> (:exception (SystemError . {:error "No such file or directory" :code 2 :parameters "./test/my_dir_that_does_not_exist" :procedure readdir}))

(count (readdir "./test/my_test_dir"))
> 3

(count (map (fn (n) (get n :name)) (readdir "./test/my_test_dir")))
> 3
