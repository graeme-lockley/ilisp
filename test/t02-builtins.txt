(car)
> (:exception (ExpectedArgumentCount . {:arguments () :arg-count 1 :procedure car}))

(car 1)
> (:exception (InvalidArgument . {:received 1 :expected-type "pair" :arg-number 0 :procedure car}))

(car '(1 2) '(3 4))
> (:exception (ExpectedArgumentCount . {:arguments ((1 2) (3 4)) :arg-count 1 :procedure car}))

(car '())
> (:exception (InvalidArgument . {:received () :expected-type "pair" :arg-number 0 :procedure car}))

(car '(1 2 3 4 5))
> 1


(cdr)
> (:exception (ExpectedArgumentCount . {:arguments () :arg-count 1 :procedure cdr}))

(cdr 1)
> (:exception (InvalidArgument . {:received 1 :expected-type "pair" :arg-number 0 :procedure cdr}))

(cdr '(1 2) '(3 4))
> (:exception (ExpectedArgumentCount . {:arguments ((1 2) (3 4)) :arg-count 1 :procedure cdr}))

(cdr '())
> (:exception (InvalidArgument . {:received () :expected-type "pair" :arg-number 0 :procedure cdr}))

(cdr '(1 2 3 4 5))
> (2 3 4 5)


(count)
> (:exception (ExpectedArgumentCount . {:arguments () :arg-count 1 :procedure list-count}))

(count 1)
> (:exception (InvalidArgument . {:received 1 :expected-type pair :arg-number 0 :procedure list-count}))

(count '(1 2) '(3 4))
> (:exception (ExpectedArgumentCount . {:arguments ((1 2) (3 4)) :arg-count 1 :procedure list-count}))

(count '())
> 0

(count '(1 2 3 4 5))
> 5

(do (assoc! (car **root**) 'fred {}) fred)
> {}

(assoc! fred 'a 1)
> {a 1}

fred
> {a 1}

(assoc! fred 'b 2)
> {b 2 a 1}

fred
> {b 2 a 1}

(assoc! fred)
> {b 2 a 1}

(assoc! fred 'b 3)
> {b 3 a 1}

fred
> {b 3 a 1}

(assoc! fred :b 4)
> {:b 4 b 3 a 1}

fred
> {:b 4 b 3 a 1}

(assoc! fred a 1)
> (:exception (UnknownSymbol . {name a}))

(dissoc! fred)
> {:b 4 b 3 a 1}

(dissoc! fred 'a)
> {:b 4 b 3}

fred
> {:b 4 b 3}

(list 1 2 3)
> (1 2 3)

(list? 0)
> ()

(list? "hello")
> ()

(list? 'fred)
> ()

(list? :at)
> ()

(list? [1])
> ()

(list? {:a 1})
> ()

(list? list)
> ()

(list? list?)
> ()

(list? ())
> t

(list? '(1 2 3))
> t

(list? '(1 2) '(3 4))
> (:exception (ExpectedArgumentCount . {:arguments ((1 2) (3 4)) :arg-count 1 :procedure list?}))

(pr-str)
> ""

(pr-str 1)
> "1"

(pr-str "hello" 'fred :at [1] {:a 1} '() '(1 (a b c) 3))
> "\"hello\" fred :at [1] {:a 1} () (1 (a b c) 3)"

(str)
> ""

(str 1)
> "1"

(str "hello" 'fred :at [1] {:a 1} '() '(1 (a b c) 3))
> "hellofred:at[1]{:a 1}()(1(abc)3)"

(=)
> t

(= 1)
> t

(= 2 2)
> t

(= 2 1)
> ()

(= 2 (+ 1 1) (- 3 1))
> t

(= 2 (+ 1 1) (- 4 1))
> ()

(= 2 '())
> ()

(= 2 "hello")
> ()

(= 2 'fred)
> ()

(= 2 :key)
> ()

(= 2 [1 2])
> ()

(= 2 '(1 2))
> ()

(= 2 {:a 1 :b 2})
> ()

(= '() '())
> t

(= "hello" "world")
> ()

(= "hello" "hello")
> t

(= "hello" '())
> ()

(= "hello" 'fred)
> ()

(= "hello" :key)
> ()

(= "hello" [1 2])
> ()

(= "hello" '(1 2))
> ()

(= "hello" {:a 1 :b 2})
> ()

(= 'hello 'fred)
> ()

(= 'hello 'hello)
> t

(= 'hello :key)
> ()

(= 'hello [1 2])
> ()

(= 'hello '(1 2))
> ()

(= 'hello {:a 1 :b 2})
> ()

(= :hello :key)
> ()

(= :hello :hello)
> t

(= :hello [1 2])
> ()

(= :hello '(1 2))
> ()

(= :hello {:a 1 :b 2})
> ()

(= [1 2] [1 2])
> t

(= [1 2] [1 2 3])
> ()

(= [] [1 2])
> ()

(= [] [])
> t

(= [1 2] '(1 2))
> ()

(= [1 2] {:a 1 :b 2})
> ()

(= '(1 2) '(1 2))
> t

(= '(1 2 3) '(1 2))
> ()

(= '(1 2 3) '())
> ()

(= '(1 2) {:a 1 :b 2})
> ()

(= {:a 1 :b 2} {:a 1 :b 2})
> t

(= {:b 2 :a 1} {:a 1 :b 2})
> t

(= {:b 2 :a 1} {:a 1})
> ()

(= {} {})
> t

(<)
> t

(< 1)
> t

(< 1 2)
> t

(< 1 2 3)
> t

(< 1 1)
> ()

(< "hello" 1)
> (:exception (InvalidArgument . {:received "hello" :expected-type "number" :arg-number 0 :procedure integer-less-than}))

(< 1 "hello")
> (:exception (InvalidArgument . {:received "hello" :expected-type "number" :arg-number 1 :procedure integer-less-than}))

(<=)
> t

(<= 1)
> t

(<= 1 2)
> t

(<= 1 2 3)
> t

(<= 1 1)
> t

(<= 1 0)
> ()

(<= "hello" 1)
> (:exception (InvalidArgument . {:received "hello" :expected-type "number" :arg-number 0 :procedure integer-less-equal}))

(>)
> t

(> 1)
> t

(> 2 1)
> t

(> 3 2 1)
> t

(> 1 1)
> ()

(> "hello" 1)
> (:exception (InvalidArgument . {:received "hello" :expected-type "number" :arg-number 0 :procedure integer-greater-than}))

(>=)
> t

(>= 1)
> t

(>= 2 1)
> t

(>= 3 2 1)
> t

(>= 1 1)
> t

(>= 0 1)
> ()

(>= "hello" 1)
> (:exception (InvalidArgument . {:received "hello" :expected-type "number" :arg-number 0 :procedure integer-greater-equal}))

(read-string)
> (:exception (ExpectedArgumentCount . {:arguments () :max-arg-count 2 :min-arg-count 1 :procedure read-string}))

(read-string 1)
> (:exception (InvalidArgument . {:received 1 :expected-type "string" :arg-number 0 :procedure read-string}))

(read-string "1")
> 1

(read-string "(1 2 3)")
> (1 2 3)

(read-string "(1 2 \"hello\")")
> (1 2 "hello")

(eval '1)
> 1

(eval '(+ 1 2))
> 3

(eval (read-string "(cdr '(1 2 3 4 5))"))
> (2 3 4 5)

(do (load-file "./test/basic.sc") (caar '((1 2) (3 4))))
> 1

(do (load-file "./test/basic.sc") (cadr '((1 2) (3 4))))
> (3 4)

(cons 1 ())
> (1)

(cons 1 (cons 2 (cons 3 (cons 4 ()))))
> (1 2 3 4)

(cons 1 '(2 3 4))
> (1 2 3 4)

(concat)
> ()

(concat () () ())
> ()

(concat 1 2 3)
> (:exception (InvalidArgument . {:received 1 :expected-type "pair" :arg-number 0 :procedure concat}))

(concat '(1 2 3) (cons 1 9))
> (:exception (InvalidArgument . {:received (1 . 9) :expected-type "pair" :arg-number 1 :procedure concat}))

(concat '(1) '(2) '(3))
> (1 2 3)

(concat '(1 2 3) '(4 5 6) '(7 8 9))
> (1 2 3 4 5 6 7 8 9)

;; Testing nth, first and rest functions with lists
(nth (list 1) 0)
>1
(nth (list 1 2) 1)
>2
(nth (list 1 2 ()) 2)
>()
(do 
  (assoc! (car **root**) 'x "x") 
  (assoc! (car **root**) 'x (nth (list 1 2) 2)) 
  x)
>()

(first (list))
>()
(first (list 6))
>6
(first (list 7 8 9))
>7

(rest (list))
>()
(rest (list 6))
>()
(rest (list 7 8 9))
>(8 9)

;; Testing nth, first, rest with vectors
(nth [1] 0)
>1
(nth [1 2] 1)
>2
(nth [1 2] 2)
>()
(nth [1 2 ()] 2)
>()

(first [])
>()
(first [10])
>10
(first [10 11 12])
>10
(rest [])
>()
(rest ())
>()
(rest [10])
>[]
(rest [10 11 12])
>[11 12]
(rest (cons 10 [11 12]))
>(11 12)

(apply)
> (:exception (InvalidArgument . {:received () :expected-type "pair" :arg-number 0 :procedure apply}))

(apply 1)
> (:exception (InvalidArgument . {:received 1 :expected-type "procedure" :arg-number 0 :procedure apply}))

(apply +)
> (:exception (InvalidArgument . {:received () :expected-type "pair" :arg-number 1 :procedure apply}))

(apply + '(1 2 3))
> 6

(apply + 1 2 '(3 4))
> 10

(apply + 1 2 3)
> (:exception (InvalidArgument . {:received 3 :expected-type "pair" :arg-number 3 :procedure apply}))

(apply + 1 2 3 '())
> 6

(apply + [1 2 3])
> 6

(apply + 1 2 [3 4])
> 10

(apply + 1 2 3 [])
> 6

(apply + 1 2 3 [])
> 6

(map)
> (:exception (ExpectedArgumentCount . {:arguments () :arg-count 2 :procedure map}))

(map (fn (n) (+ n 1)))
> (:exception (ExpectedArgumentCount . {:arguments ((#PROCEDURE (n) (+ n 1))) :arg-count 2 :procedure map}))

(map 1 (fn (n) (+ n 1)))
> (:exception (InvalidArgument . {:received 1 :expected-type (pair vector () string) :arg-number 0 :procedure map}))

(map '() (fn (n) (+ n 1)))
> ()

(map '(1 2 3 4) (fn (n) (+ n 1)))
> (2 3 4 5)

(map [] (fn (n) (+ n 1)))
> ()

(map [1 2 3 4] (fn (n) (+ n 1)))
> (2 3 4 5)

(hash-map)
> {}

(map? (hash-map))
> t

(hash-map :a 1 :b 2 :c 3)
> {:a 1 :b 2 :c 3}

(map? (hash-map :a 1 :b 2 :c 3))
> t

(hash-map :a 1 :b 2 :c)
> (:exception (InvalidArgument . {:received () :expected-type "pair" :arg-number 5 :procedure hash-map}))

(assoc {})
> {}

(assoc {} :a 1 :b 2 :c 3)
> {:c 3 :b 2 :a 1}

(do (assoc! (car **root**) 'a {:a 1 :b 2 :c 3}) (list (assoc a :a 2 :b 3) a))
> ({:b 3 :a 2 :c 3} {:a 1 :b 2 :c 3})

(dissoc {:a 1 :b 2 :c 3} :a :b)
> {:c 3}

(dissoc {:a 1 :b 2 :c 3} :a :b :d)
> {:c 3}

(do (assoc! (car **root**) 'a {:a 1 :b 2 :c 3}) (list (dissoc a :a :b) a))
> ({:c 3} {:a 1 :b 2 :c 3})

(get)
> (:exception (InvalidArgument . {:received () :expected-type "pair" :arg-number 0 :procedure get}))

(get {})
> {}

(get [] :a)
> (:exception (InvalidArgument . {:received [] :expected-type map :arg-number 0 :procedure get}))

(get {} :a)
> ()

(get {:a 1 :b 2 :c 3} :a)
> 1

(get {:a 1 :b 2 :c 3} :c)
> 3

(get {:a 1 :b 2 :c 3} :d)
> ()

(get {:a 1 :b () :c 3} :b)
> ()

(get {:a 1 :b {"a" 1 "b" 2} :c 3} :b "b")
> 2

(get {:a 1 :b {"a" 1 "b" 2} :c 3} :a "a")
> (:exception (InvalidArgument . {:received 1 :expected-type map :arg-number 0 :procedure get}))

(contains?)
> (:exception (ExpectedArgumentCount . {:arguments () :arg-count 2 :procedure contains?}))

(contains? {})
> (:exception (ExpectedArgumentCount . {:arguments ({}) :arg-count 2 :procedure contains?}))

(contains? [] :a)
> (:exception (InvalidArgument . {:received ([] :a) :expected-type map :arg-number 0 :procedure contains?}))

(contains? {} :a)
> f

(contains? {:a 1 :b 2 :c 3} :a)
> t

(contains? {:a 1 :b 2 :c 3} :c)
> t

(contains? {:a 1 :b 2 :c 3} :d)
> f

(contains? {:a 1 :b () :c 3} :b)
> t

(keys)
> (:exception (ExpectedArgumentCount . {:arguments () :arg-count 1 :procedure keys}))

(keys [])
> (:exception (InvalidArgument . {:received [] :expected-type map :arg-number 0 :procedure keys}))

(keys {})
> ()

(keys {:a 1 :b 2 :c 3})
> (:a :b :c)

(vals)
> (:exception (ExpectedArgumentCount . {:arguments () :arg-count 1 :procedure vals}))

(vals [])
> (:exception (InvalidArgument . {:received [] :expected-type map :arg-number 0 :procedure vals}))

(vals {})
> ()

(vals {:a 1 :b 2 :c 3})
> (1 2 3)

((get (car **root**) :builtins 'read-dir) "./test/my_dir_that_does_not_exist")
> (:exception (SystemError . {:error "No such file or directory" :code 2 :parameters "./test/my_dir_that_does_not_exist" :procedure read-dir}))

(count ((get (car **root**) :builtins 'read-dir) "./test/my_test_dir"))
> 3

(count (map ((get (car **root**) :builtins 'read-dir) "./test/my_test_dir") (fn (n) (get n :name))))
> 3

(do (assoc! (car **root**) 'file-name-relative-to-file-name (get (car **root**) :builtins 'file-name-relative-to-file-name)) ())
> ()

(file-name-relative-to-file-name "/home/ilisp/prelude.scm" "/dir/bob.scm")
> "/dir/bob.scm"

(file-name-relative-to-file-name "/home/ilisp/prelude.scm" "./dir/bob.scm")
> "/home/ilisp/dir/bob.scm"

(file-name-relative-to-file-name "/home/ilisp/prelude.scm" "../dir/bob.scm")
> "/home/dir/bob.scm"

(file-name-relative-to-file-name "/home/ilisp/prelude.scm" "./.././dir/bob.scm")
> "/home/dir/bob.scm"

(file-name-relative-to-file-name "/home/ilisp/prelude.scm" "./.././.././dir/bob.scm")
> "/dir/bob.scm"

(file-name-relative-to-file-name "/home/ilisp/prelude.scm" "./.././.././.././dir/bob.scm")
> "/dir/bob.scm"
